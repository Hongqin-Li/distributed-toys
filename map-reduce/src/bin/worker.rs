use atomicwrites::{AtomicFile, DisallowOverwrite};
use map_reduce::{ReportReply, RequestReply, TaskType};
use serde::{Deserialize, Serialize};
use std::hash::{Hash, Hasher};
use std::net::SocketAddr;
use std::path::PathBuf;
use std::{collections::hash_map::DefaultHasher, io::Write};
use std::{collections::HashMap, fs};
use structopt::StructOpt;
use tarpc::{client, context, tokio_serde::formats::Json};

use map_reduce::app::wc::{map, reduce};
#[derive(Debug, Serialize, Deserialize)]
struct IntermediateFile {
    values: Vec<(String, String)>,
}

#[derive(StructOpt, Debug)]
#[structopt(name = env!("CARGO_PKG_NAME"), version = env!("CARGO_PKG_VERSION"), about = env!("CARGO_PKG_DESCRIPTION"), author = env!("CARGO_PKG_AUTHORS"))]
struct Opt {
    #[structopt(short, long)]
    server: String,
}

fn intermediate_path(map_idx: usize, reduce_idx: usize) -> PathBuf {
    [
        "target",
        format!("mr-{}-{}.json", map_idx, reduce_idx).as_ref(),
    ]
    .iter()
    .collect()
}

fn output_path(reduce_idx: usize) -> PathBuf {
    ["target", format!("mr-out-{}.json", reduce_idx).as_ref()]
        .iter()
        .collect()
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let opt = Opt::from_args();

    let server_addr = opt.server;
    let server_addr = server_addr
        .parse::<SocketAddr>()
        .unwrap_or_else(|e| panic!(r#"--server_addr value "{}" invalid: {}"#, server_addr, e));

    let mut transport = tarpc::serde_transport::tcp::connect(server_addr, Json::default);
    transport.config_mut().max_frame_length(4294967296);

    // ServiceClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let mut client =
        map_reduce::ServiceClient::new(client::Config::default(), transport.await?).spawn()?;

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    loop {
        let resp: RequestReply = client.request(context::current()).await?;
        if let Some(t) = resp.task {
            let nreduce = resp.nreduce;
            let nmap = resp.nmap;
            match t.task {
                TaskType::Map => {
                    for fname in t.files.iter() {
                        let mut cnt = HashMap::<usize, Vec<(String, String)>>::new();
                        let contents = fs::read_to_string(fname).expect("Error on reading file");
                        for (k, v) in map(fname, &contents) {
                            let mut hasher = DefaultHasher::new();
                            k.hash(&mut hasher);
                            let r = (hasher.finish() as usize) % nreduce;
                            let x = cnt.get_mut(&r);
                            if let Some(xv) = x {
                                xv.push((k, v));
                            } else {
                                cnt.insert(r, Vec::from([(k, v)]));
                            }
                        }

                        for (i, values) in cnt.iter() {
                            let path = intermediate_path(t.id, i.to_owned());
                            println!("{:?}", path);
                            let af = AtomicFile::new(path, DisallowOverwrite);
                            af.write(|f| {
                                f.write_all(serde_json::to_string(&values).unwrap().as_bytes())
                            })
                            .unwrap();
                            // fs::write(path, serde_json::to_string_pretty(&values).unwrap()).unwrap();
                        }
                    }
                }
                TaskType::Reduce => {

                    let mut map: HashMap<String, Vec<String>> = HashMap::new();
                    for i in 0..resp.nmap {
                        // Reduce
                        let path = intermediate_path(i, t.id);
                        let s = fs::read_to_string(path).unwrap();
                        let values: Vec<(String, String)> = serde_json::from_str(s.as_ref())?;
                        for (k, v) in values.iter() {
                            let bucket = map.get_mut(k);
                            if let Some(vs) = bucket {
                                vs.push(v.clone());
                            } else {
                                map.insert(k.clone(), Vec::from([v.clone()]));
                            }
                        }
                    }
                    let mut result: HashMap<String, String> = HashMap::new();
                    for (k, vs) in map.iter() {
                        result.insert(k.clone(), reduce(k, vs));
                    }
                    println!("Reduce values: {:?}", map);

                    // Output
                    let path = output_path(t.id);
                    let af = AtomicFile::new(path, DisallowOverwrite);
                    af.write(|f| f.write_all(serde_json::to_string(&result).unwrap().as_bytes()))
                        .unwrap();
                }
            }
            client.report(context::current(), t.id).await?;
        } else {
            break;
        }
    }

    Ok(())
}
